"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3653],{86858:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=n(83117),a=(n(67294),n(3905));const o={title:"VAST v2.3",description:"Automatic Rebuilds",authors:"dominiklohmann",date:new Date("2022-09-01T00:00:00.000Z"),tags:["release","rebuild","performance"]},r=void 0,s={permalink:"/blog/vast-v2.3",source:"@site/blog/vast-v2.3/index.md",title:"VAST v2.3",description:"Automatic Rebuilds",date:"2022-09-01T00:00:00.000Z",formattedDate:"September 1, 2022",tags:[{label:"release",permalink:"/blog/tags/release"},{label:"rebuild",permalink:"/blog/tags/rebuild"},{label:"performance",permalink:"/blog/tags/performance"}],readingTime:3.905,hasTruncateMarker:!0,authors:[{name:"Dominik Lohmann",title:"Engineering Manager",url:"https://github.com/dominiklohmann",email:"dominik@tenzir.com",imageURL:"https://github.com/dominiklohmann.png",key:"dominiklohmann"}],frontMatter:{title:"VAST v2.3",description:"Automatic Rebuilds",authors:"dominiklohmann",date:"2022-09-01T00:00:00.000Z",tags:["release","rebuild","performance"]},prevItem:{title:"Public Roadmap and Open RFCs",permalink:"/blog/public-roadmap-and-open-rfcs"},nextItem:{title:"Richer Typing in Sigma",permalink:"/blog/richer-typing-in-sigma"}},l={authorsImageUrls:[void 0]},d=[{value:"Automatic Rebuilds",id:"automatic-rebuilds",level:2},{value:"Optional Partition Indexes",id:"optional-partition-indexes",level:2},{value:"Improved Responsiveness Under High Load",id:"improved-responsiveness-under-high-load",level:2}],p={toc:d};function u(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/tenzir/vast/releases/tag/v2.3.0"},"VAST v2.3")," is now available, which introduces an automatic\ndata defragmentation capability."),(0,a.kt)("h2",{id:"automatic-rebuilds"},"Automatic Rebuilds"),(0,a.kt)("p",null,"VAST server processes now continuously rebuild partitions in the background. The\nfollowing diagram visualizes what happens under the hood:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Rebuild",src:n(34591).Z+"#gh-light-mode-only",width:"1840",height:"846"}),"\n",(0,a.kt)("img",{alt:"Rebuild",src:n(25024).Z+"#gh-dark-mode-only",width:"1840",height:"846"})),(0,a.kt)("p",null,"Rebuilding kicks in when a partition has the following properties:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Outdated"),": if a partitions does not have the latest partition version, it\nmay not enjoy the latest features and optimizations. It makes it also faster\nto adopt VAST versions that include breaking changes in the storage layout.\nTherefore, VAST rebuilds outdated partitions to bring them into the most\nrecent state.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Undersized"),": numerous small partitions can cause fragmentation in the\ncatalog, causing higher memory consumption, larger database footprint, and\nslower queries. Rebuilding merges undersized partitions, thereby\ndefragmenting the system. This reduces the resource footprint and makes\nqueries faster."))),(0,a.kt)("p",null,"To enable automatic rebuilding, set the new ",(0,a.kt)("inlineCode",{parentName:"p"},"vast.automatic-rebuild")," option."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"vast:\n  # Control automatic rebuilding of partitions in the background for\n  # optimization purposes. The given number controls how many rebuilds to run\n  # concurrently, and thus directly controls the performance vs. memory and CPU\n  # usage trade-off. Set to 0 to disable. Defaults to 1.\n  automatic-rebuild: 1\n")),(0,a.kt)("p",null,"Now that we have an LSM-style merge operation of partitions, we reduced\nthe partition cutoff timeout to 5 minutes from 1 hour by default (controlled\nthrough the option ",(0,a.kt)("inlineCode",{parentName:"p"},"vast.active-partition-timeout"),"). This reduces the risk of\ndata loss in case of a crash. This comes in handy in particular for low-volume\ndata sources that never exhaust their capacity."),(0,a.kt)("h2",{id:"optional-partition-indexes"},"Optional Partition Indexes"),(0,a.kt)("p",null,"Historically, VAST evolved from a special-purpose bitmap indexing system into a\ngeneral-purpose telemetry engine for security data. Today, VAST has a two-tiered\nindexing architecture with sparse sketch structures at the top, followed by a\nsecond layer of dense indexes. As of this release, it is possible to disable\nthis second layer."),(0,a.kt)("p",null,"The space savings can be substantial based on the size of your index. For\nexample, if the first layer of indexing always yields highly selective results,\nthen it the dense indexes do not provide a lot of value. One scenario would be\nretro-matching: if you only do IoC-style point queries, they will be most likely\ncovered well by the sketches. If you do not have selective queries, the dense\nindex is not helping much anyway, since you need access the base data anyway. A\nreally good use case for the indexes when your have a scatterd data access\npatterns, i.e., highly selective results ",(0,a.kt)("em",{parentName:"p"},"within")," a partition, but a result that\nspans many disparate partitions."),(0,a.kt)("p",null,"In a simplified model, VAST performs three steps when executing a query:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Send the query to the catalog, which maintains VAST's partitions, and ask it\nfor a list of candidate partitions. The catalog maintains the first tier of\nsparse indexes, currently one per partition.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Send the query to all candidate partitions in parallel, each of which\ncontains dense indexes for all fields in the partition's schema. The index\nlookup yields a set of candidate records IDs within the partition.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Send the query to all candidate partition's stores, provided the index lookup\nyielded record IDs. Then evaluating the query against the candidate events\nand return the result."))),(0,a.kt)("p",null,"Here's how you can configure a partition index to be disabled:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"vast:\n  index:\n    rules:\n        # Don't create partition indexes the suricata.http.http.url field.\n      - targets:\n          - suricata.http.http.url\n        partition-index: false\n        # Don't create partition indexes for fields of type addr.\n      - targets:\n          - :addr\n        partition-index: false\n")),(0,a.kt)("h2",{id:"improved-responsiveness-under-high-load"},"Improved Responsiveness Under High Load"),(0,a.kt)("p",null,"Two small changes improve VAST's behavior under exceptionally high load."),(0,a.kt)("p",null,"First, the new ",(0,a.kt)("inlineCode",{parentName:"p"},"vast.connection-timeout")," option allows for modifying the default\nclient-to-server connection timeout of 10 seconds. Previously, if a VAST server\nwas too busy to respond to a new client within 10 seconds, the client simply\nexited with an unintelligable ",(0,a.kt)("inlineCode",{parentName:"p"},"request_timeout")," error message. Here's how you\ncan set a custom timeout:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"vast:\n  # The timeout for connecting to a VAST server. Set to 0 seconds to wait\n  # indefinitely.\n  connection-timeout: 10s\n")),(0,a.kt)("p",null,"The option is additionally available under the environment variable\n",(0,a.kt)("inlineCode",{parentName:"p"},"VAST_CONNECTION_TIMEOUT")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"--connection-timeout")," command-line option."),(0,a.kt)("p",null,"Second, we improved the operability of VAST servers under high load from\nautomated low-priority queries. We noticed that when spawning thousands of\nautomated retro-match queries that compaction would stall and make little\nvisible progress, risking the disk running full or no longer being compliant\nwith GDPR-related policies enforced by compaction."),(0,a.kt)("p",null,"To ensure that compaction's internal and regular user-issued queries work as\nexpected even in this scenario, VAST now considers queries issued with\n",(0,a.kt)("inlineCode",{parentName:"p"},"--low-priority"),", with even less priority compared to regular queries (down from\n33.3% to 4%) and internal high-priority queries used for rebuilding and\ncompaction (down from 12.5% to 1%)."))}u.isMDXComponent=!0},25024:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/rebuild-dark-4efcc9a924014c95fdfe8568ee53aacc.png"},34591:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/rebuild-light-949cb7d0044aa66bc94342608227cbb7.png"}}]);